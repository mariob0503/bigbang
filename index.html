<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Big Bang Simulation</title>
  <style>
    /* Ensure the demo fills the entire browser window */
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000; /* Black background for deep space feel */
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <!--
    IMPORTANT: This demo uses the three.js and dat.GUI libraries loaded via CDN.
    The simulation creates a particle system that begins as a singularity at the origin.
    Each particle is given a random velocity so that when animated, they appear to expand outward
    like the Big Bang. The scene also includes a point light to simulate a glowing center,
    and the entire scene rotates slowly for added dynamism.
  -->

  <!-- Load three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Load dat.GUI for UI controls -->
  <script src="https://cdn.jsdelivr.net/npm/dat.gui"></script>
  
  <script>
    /*******************************************
     * Module: Global Variables and Initialization
     *******************************************/
    let scene, camera, renderer;
    let particleSystem;
    let clock;
    let gui, guiControls;

    // Initialize scene, camera, renderer, and simulation components
    init();
    animate();

    /**
     * init()
     * Sets up the scene, camera, renderer, lighting, particle system, and GUI controls.
     */
    function init() {
      // Create a new scene with a subtle exponential fog for depth
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.00025);

      // Create a Perspective Camera
      camera = new THREE.PerspectiveCamera(
        75, window.innerWidth / window.innerHeight, 1, 10000
      );
      camera.position.z = 50; // Initial zoom level

      // Set up the WebGL renderer with antialiasing and shadow support
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Clock to drive the animation loop
      clock = new THREE.Clock();

      // Ambient light for general illumination
      const ambientLight = new THREE.AmbientLight(0x222222);
      scene.add(ambientLight);

      // Point light simulating the energetic center of the explosion.
      // This light also casts shadows for added realism.
      const pointLight = new THREE.PointLight(0xffaa55, 2, 500);
      pointLight.position.set(0, 0, 0);
      pointLight.castShadow = true;
      scene.add(pointLight);

      // Create the particle system that represents the exploding matter
      createParticleSystem();

      // Initialize the GUI controls to allow dynamic parameter adjustments
      initGUI();

      // Listen for browser window resize events
      window.addEventListener('resize', onWindowResize, false);
    }

    /*******************************************
     * Module: Particle System Setup
     *******************************************/
    /**
     * createParticleSystem()
     * Builds a particle system starting from a singularity.
     * Each particle is initialized at the origin with a random velocity
     * to simulate an expanding explosion.
     */
    function createParticleSystem() {
      const particleCount = 20000;
      const geometry = new THREE.BufferGeometry();

      // Create typed arrays for positions and velocities.
      // Positions: all start at the origin.
      // Velocities: random direction and speed for each particle.
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        // Start all particles at the singularity (origin)
        positions[i * 3]     = 0;
        positions[i * 3 + 1] = 0;
        positions[i * 3 + 2] = 0;

        // Define a random direction using spherical coordinates
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos((Math.random() * 2) - 1);
        const speed = Math.random() * 0.5 + 0.5; // Base speed

        velocities[i * 3]     = speed * Math.sin(phi) * Math.cos(theta);
        velocities[i * 3 + 1] = speed * Math.sin(phi) * Math.sin(theta);
        velocities[i * 3 + 2] = speed * Math.cos(phi);
      }

      // Add the arrays as attributes to the geometry
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

      // Create a PointsMaterial with additive blending for a luminous effect.
      const material = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1.5,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      // Create the particle system and add it to the scene.
      particleSystem = new THREE.Points(geometry, material);
      scene.add(particleSystem);
    }

    /*******************************************
     * Module: GUI Controls
     *******************************************/
    /**
     * initGUI()
     * Sets up dat.GUI controls to allow the user to modify simulation parameters in real time.
     */
    function initGUI() {
      // Default simulation parameters
      guiControls = {
        expansionSpeed: 1.0,
        particleSize: 1.5,
        cameraZoom: 50
      };

      // Create the GUI and add controllers for each parameter
      gui = new dat.GUI();
      gui.add(guiControls, 'expansionSpeed', 0.1, 5.0)
         .name('Expansion Speed');
      gui.add(guiControls, 'particleSize', 0.5, 5.0)
         .name('Particle Size')
         .onChange(function(value) {
           // Update particle size immediately when changed
           particleSystem.material.size = value;
         });
      gui.add(guiControls, 'cameraZoom', 10, 200)
         .name('Camera Zoom')
         .onChange(function(value) {
           // Adjust the camera's z position
           camera.position.z = value;
         });
    }

    /*******************************************
     * Module: Event Handling
     *******************************************/
    /**
     * onWindowResize()
     * Updates camera and renderer dimensions when the browser window is resized.
     */
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    /*******************************************
     * Module: Animation Loop
     *******************************************/
    /**
     * animate()
     * The main render loop that updates particle positions, animates the camera, and renders the scene.
     */
    function animate() {
      // Schedule the next frame
      requestAnimationFrame(animate);

      // Get the time elapsed since the last frame
      const delta = clock.getDelta();
      const positions = particleSystem.geometry.attributes.position.array;
      const velocities = particleSystem.geometry.attributes.velocity.array;
      const count = positions.length / 3;

      // Update each particle's position based on its velocity and the expansion speed.
      for (let i = 0; i < count; i++) {
        positions[i * 3]     += velocities[i * 3]     * delta * guiControls.expansionSpeed;
        positions[i * 3 + 1] += velocities[i * 3 + 1] * delta * guiControls.expansionSpeed;
        positions[i * 3 + 2] += velocities[i * 3 + 2] * delta * guiControls.expansionSpeed;
      }
      // Mark the attribute as needing an update
      particleSystem.geometry.attributes.position.needsUpdate = true;

      // Slowly rotate the entire scene to provide a dynamic, exploratory view
      scene.rotation.y += 0.001;

      // Animate the camera in an orbit around the center of the explosion
      const time = clock.elapsedTime * 0.1;
      camera.position.x = guiControls.cameraZoom * Math.sin(time);
      camera.position.z = guiControls.cameraZoom * Math.cos(time);
      camera.lookAt(scene.position);

      // Render the scene using the current camera view
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
